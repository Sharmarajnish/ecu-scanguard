/*
 * Real-World Automotive ECU Vulnerability Test Case
 * Based on actual CVE reports and security research
 * 
 * This file contains intentional vulnerabilities for testing purposes
 * DO NOT USE IN PRODUCTION SYSTEMS
 */


// Volkswagen Group ECU Vulnerability
// Real vulnerability: Weak cryptographic implementation in ECUs

#include <stdio.h>
#include <string.h>
#include <openssl/aes.h>

// VULNERABLE: Weak AES implementation
void encrypt_ecu_data(char* data, int length) {
    AES_KEY key;
    char iv[16] = {0};  // VULNERABLE: Zero IV
    
    // VULNERABLE: Hardcoded encryption key
    char encryption_key[] = "vw_ecu_key_2020";
    
    AES_set_encrypt_key(encryption_key, 128, &key);
    AES_cbc_encrypt(data, data, length, &key, iv, AES_ENCRYPT);
}

// VULNERABLE: Predictable random number generation
int generate_ecu_id() {
    return rand() % 1000000;  // Predictable
}

// VULNERABLE: No authentication for ECU updates
void update_ecu_firmware(const char* firmware_data) {
    // VULNERABLE: No signature verification
    write_firmware_to_ecu(firmware_data);
}

// VULNERABLE: Hardcoded diagnostic keys
const char* vw_diagnostic_key = "volkswagen_diag_2020";
const char* service_key = "vw_service_mode";
const char* engineering_key = "vw_engineering_access";

// VULNERABLE: Buffer overflow in CAN message processing
void process_can_message_vw(uint32_t can_id, uint8_t* data) {
    char message_buffer[128];
    
    // VULNERABLE: No bounds checking
    sprintf(message_buffer, "CAN_ID: 0x%X, Data: %s", can_id, data);
    
    // VULNERABLE: Stack overflow
    char large_buffer[512];
    strcpy(large_buffer, message_buffer);
}

// VULNERABLE: Weak hash function for integrity checking
void verify_firmware_integrity(const char* firmware) {
    // VULNERABLE: Using MD5 for integrity
    char hash[MD5_DIGEST_LENGTH * 2 + 1];
    MD5_CTX ctx;
    MD5_Init(&ctx);
    MD5_Update(&ctx, firmware, strlen(firmware));
    MD5_Final(hash, &ctx);
    
    // VULNERABLE: No proper integrity verification
    if (strcmp(hash, "expected_hash") == 0) {
        firmware_valid = 1;
    }
}
