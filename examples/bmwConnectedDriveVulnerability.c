/*
 * Real-World Automotive ECU Vulnerability Test Case
 * Based on actual CVE reports and security research
 * 
 * This file contains intentional vulnerabilities for testing purposes
 * DO NOT USE IN PRODUCTION SYSTEMS
 */


// BMW ConnectedDrive Vulnerability
// Real vulnerability: Authentication bypass in telematics system

#include <stdio.h>
#include <string.h>
#include <openssl/md5.h>

// VULNERABLE: MD5 hash for authentication (weak)
void authenticate_user(const char* username, const char* password) {
    char hash[MD5_DIGEST_LENGTH * 2 + 1];
    char stored_hash[] = "5d41402abc4b2a76b9719d911017c592";  // "hello" in MD5
    
    // VULNERABLE: MD5 is cryptographically broken
    MD5_CTX ctx;
    MD5_Init(&ctx);
    MD5_Update(&ctx, password, strlen(password));
    MD5_Final(hash, &ctx);
    
    if (strcmp(hash, stored_hash) == 0) {
        grant_access();
    }
}

// VULNERABLE: Hardcoded API keys
const char* bmw_api_key = "bmw_connected_drive_2021";
const char* telematics_key = "telematics_secret_key";
const char* diagnostic_key = "bmw_diag_2021";

// VULNERABLE: SQL injection in telematics database
void query_vehicle_data(const char* vin) {
    char query[512];
    
    // VULNERABLE: SQL injection
    sprintf(query, "SELECT * FROM vehicles WHERE vin='%s'", vin);
    execute_sql_query(query);
}

// VULNERABLE: No rate limiting on diagnostic requests
void request_diagnostic_data(const char* vin) {
    // VULNERABLE: No rate limiting
    send_diagnostic_request(vin);
}

// VULNERABLE: Weak session management
typedef struct {
    char session_id[32];
    time_t expiry;
    int privileges;
} session_t;

session_t* create_session(const char* user) {
    session_t* session = malloc(sizeof(session_t));
    
    // VULNERABLE: Predictable session ID
    sprintf(session->session_id, "session_%d", rand());
    session->expiry = time(NULL) + 3600;  // 1 hour
    session->privileges = 0;
    
    return session;
}
