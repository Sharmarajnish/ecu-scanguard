/*
 * Real-World Automotive ECU Vulnerability Test Case
 * Based on actual CVE reports and security research
 * 
 * This file contains intentional vulnerabilities for testing purposes
 * DO NOT USE IN PRODUCTION SYSTEMS
 */


// Tesla Model S/X CAN Bus Vulnerability (CVE-2020-12753)
// Real vulnerability: Insufficient validation of CAN messages

#include <stdio.h>
#include <string.h>
#include <stdint.h>

// Vulnerable CAN message handling
typedef struct {
    uint32_t id;
    uint8_t data[8];
    uint8_t length;
} can_message_t;

// VULNERABLE: No validation of CAN ID ranges
void process_can_message(can_message_t* msg) {
    // Critical: No bounds checking on CAN ID
    if (msg->id == 0x123) {  // Engine control message
        // VULNERABLE: Direct memory access without validation
        memcpy(&engine_control, msg->data, msg->length);
        execute_engine_command();
    }
    
    // VULNERABLE: No authentication of diagnostic messages
    if (msg->id >= 0x7E0 && msg->id <= 0x7E7) {  // UDS diagnostic range
        process_diagnostic_message(msg);
    }
}

// VULNERABLE: Buffer overflow in diagnostic processing
void process_diagnostic_message(can_message_t* msg) {
    char buffer[64];
    // VULNERABLE: No bounds checking
    strcpy(buffer, (char*)msg->data);
    
    // VULNERABLE: Format string vulnerability
    printf(buffer);  // Real vulnerability found in Tesla firmware
}

// VULNERABLE: Hardcoded diagnostic keys
const char* diagnostic_key = "tesla_diag_2020";
const char* service_key = "service_mode_enable";

// VULNERABLE: Weak authentication
int authenticate_diagnostic(const char* key) {
    return strcmp(key, diagnostic_key) == 0;  // Timing attack vulnerable
}
