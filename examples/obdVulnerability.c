/*
 * Real-World Automotive ECU Vulnerability Test Case
 * Based on actual CVE reports and security research
 * 
 * This file contains intentional vulnerabilities for testing purposes
 * DO NOT USE IN PRODUCTION SYSTEMS
 */


// OBD-II Diagnostic Vulnerability
// Real vulnerability: Unrestricted access to diagnostic functions

#include <stdio.h>
#include <string.h>
#include <stdint.h>

// VULNERABLE: No authentication for OBD-II requests
void process_obd_request(uint8_t service_id, uint8_t* data) {
    switch (service_id) {
        case 0x01:  // Show current data
            // VULNERABLE: No access control
            send_current_data();
            break;
            
        case 0x02:  // Show freeze frame data
            // VULNERABLE: No access control
            send_freeze_frame_data();
            break;
            
        case 0x03:  // Show stored DTCs
            // VULNERABLE: No access control
            send_stored_dtcs();
            break;
            
        case 0x04:  // Clear DTCs
            // VULNERABLE: Critical - no authentication
            clear_dtcs();
            break;
            
        case 0x22:  // Read data by identifier
            // VULNERABLE: No access control
            read_data_by_id(data);
            break;
            
        case 0x2E:  // Write data by identifier
            // VULNERABLE: Critical - no authentication
            write_data_by_id(data);
            break;
    }
}

// VULNERABLE: Hardcoded OBD-II security keys
const char* obd_security_key = "obd_security_2020";
const char* diagnostic_session_key = "diag_session_key";

// VULNERABLE: No rate limiting on diagnostic requests
void request_diagnostic_data(uint8_t pid) {
    // VULNERABLE: No rate limiting
    send_pid_request(pid);
}

// VULNERABLE: Buffer overflow in PID response
void send_pid_response(uint8_t pid, uint8_t* data) {
    char response_buffer[64];
    
    // VULNERABLE: No bounds checking
    sprintf(response_buffer, "PID 0x%02X: %s", pid, data);
    
    // VULNERABLE: Stack overflow
    char large_buffer[256];
    strcpy(large_buffer, response_buffer);
}
